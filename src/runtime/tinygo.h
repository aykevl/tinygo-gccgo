
#pragma once

#include "runtime.h"
#include "go-type.h"

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>

#define STACK_SIZE (2 * 1024) // 2kB
#define STACK_CANARY (0x4c5e3e8a) // generated by random.org

#if 0
#define DEBUG_printf(...) printf(__VA_ARGS__); fflush(stdout)
#else
#define DEBUG_printf(...)
#endif

typedef void (*func)(void*);

// Must be the same as type deferred in runtime.go.
typedef struct _defer_t {
	func fn;
	void *arg;
	bool *stackframe;
	struct _defer_t *next;
} defer_t;

typedef struct _panic_element_t {
	struct __go_empty_interface msg;
	void *retaddr;
	struct _panic_element_t *next;
} panic_element_t;

// Must be the same as type goroutine in runtime.go.
typedef struct _goroutine_t {
	struct _goroutine_t *next;
	struct _goroutine_t *prev;
	panic_element_t     *panicking;
	size_t     num; // for debugging only
	void       *created_by;
	defer_t    *deferred;
	uintptr_t  canary;
	uintptr_t  stack[STACK_SIZE / sizeof(uintptr_t)]; // TODO: align on page boundary
	ucontext_t context;
} goroutine_t;

typedef enum {
	CHAN_NULL,
	CHAN_SENDING,
	CHAN_CLOSED,
} chan_state_t;

typedef struct {
	chan_state_t state;
	uint64_t     value;     // value that is being sent
} channel_t;

// Every time a goroutine proceeds in any way, this is incremented.
extern size_t goroutine_work_counter;

void tinygo_unwind_fail(void *pc, String msg);
void tinygo_port_unwind(goroutine_t *r, uint32_t *pc, uint32_t *sp);
void * tinygo_alloc(size_t size);
void tinygo_free(void *ptr);
void tinygo_block();
void __go_panic(struct __go_empty_interface arg);
void tinygo_deadlocked();
void tinygo_go(void *fn, void *arg, void *created_by);
__attribute__((noreturn))
void tinygo_goroutine_exit();
void tinygo_run_internal(func fn, void *arg);
void tinygo_fatal(); // exit process or reset chip

__attribute__((noreturn))
void runtime_Panic(struct __go_empty_interface msg, bool fatal) __asm__("runtime.Panic");
void tinygo_sleep(int64_t sleeptime) __asm__("time.Sleep");
void tinygo_semacquire(volatile uint32_t *addr, bool profile) __asm__("sync.runtime_Semacquire");
void tinygo_semrelease(volatile uint32_t *addr) __asm__("sync.runtime_Semrelease");

extern void go_main() __asm__ ("main.main");

extern goroutine_t *goroutine __asm__("runtime.GR");
